The transpiler creates JVM bytecode from Python bytecode. It may not support all features of Python but is faster than the overhead of method linking.

The transpiler operated by dynamically creating code for the method in the following way:
1. Save co_consts to a constant pool.
2. Determine a method signature
3. Since the JVM Operand Stack is not compatible with Python's stack, the transpiler creates a new stack to simulate the JVM Operand Stack.
    That stack is basically a Object[] array with the length of co_stacksize.
    we will call this "pyStack" to differentiate from the JVM Operand Stack.

4. All arguments are converted to objects and pushed to the pyStack.
5. The transpiler then iterates through the bytecode and creates the equivalent JVM bytecode, manipulating the pyStack as needed.
    The Operand Stack must only contain the pyStack after each instruction.
    Some instructions may be typed. For ex. LOAD_ATTR can either be GETFIELD, INVOKEVIRTUAL or pyjvm.java.bridge.PyObject.getAttr() depending on the object type.
    This must be determined at compile time with annotations.

6. The transpiler then creates a method with the determined signature and the generated bytecode.
7. The transpiler adds a Exceptions attribute to the method
8. The transpiler adds LineNumberTable, LocalVariableTable and StackMapTable attributes to the code attribute.



during the execution of a transpiled method, no direct JNI calls are made, only the JVM bytecode.
Even though the bytecode is far from optimal, since it uses a custom stack and no primitive types, it is faster than method linking and has low to no overhead when interacting with the JVM.
Should transpilation fail, the method will be linked instead.

it the future the transpiler may be improved to remove the custom stack and use the JVM Operand Stack directly. 
This would bring huge performance improvements, and allow primitive types to be used directly.

There may also be a secondary, even more limited, transpiler that only supports a subset of Python features but is faster and more efficient.
This would only support python opcodes that utilize pop and push operations.

It should be considered that transpilation is not always the best option. When a method uses a lot of PyObjects, it may be better to link the method instead of transpiling it since PyObjects involve JNI calls.


# types
the following jvm types should be supported by the transpiler:

java/lang/Object
java/lang/String
java/lang/Long
java/lang/Doube
java/lang/Boolean

java/util/List
java/util/Map
java/util/Set

pyjvm/java/bridge/PyObject
pyjvm/java/bridge/PyList
pyjvm/java/bridge/PyDict
pyjvm/java/bridge/PySet